### 1.운영체제의 목적

- 운영체제란?  
  좁은 의미는 운영체제는 메모리에 상주하는 커널, 넓은 의미의 운영체제는 커널 뿐만 아니라 각종 주변 시스템 유틸리티를 포함한 개념

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%9E%80.png"
    width="300"
    height="300"
  />
</p>

- 컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공  
  ex) 한 대의 컴퓨터에 여러 프로그램(유투브에서 음악을 들으면서, 코딩을 하면서, 인터넷 쇼핑도 하면서)이 마치 다 따로 수행되는 듯한 환상을 제공(그러나 하나의 운영체제가 그것을 그렇게 보이도록 제공해주는 것이다.)
- 컴퓨터의 시스템의 자원(CPU, 메모리, I/O장치 등)을 효율적으로 관리 -> but 형평성도 생각해야함.(특정 프로그램만이 많은 자원을 차지하거나 하면 안됨.)  
  ex) 컴퓨터에 여러 프로그램이 동시에 실행되면 CPU가 짧은 시간씩 번갈아가면서 할당해서 우리 눈에는 전부 실행되는 것처럼 보이는 것임  
  ex) 컴퓨터에 여러 프로그램이 하나의 메모리 공간에 분배해서 실행되도록 한다.

### 2.운영체제의 기능

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EC%9D%98%20%EA%B8%B0%EB%8A%A5.png"
    width="400"
    height="400"
  />
</p>

[운영체제의 기능 설명]

- CPU동작  
  CPU의 작업공간은 메모리이다. CPU는 매 클럭마다 메모리 어딘가에 있는 기계어를 하나씩 읽어다가 연산을 한다.
- I/O디바이스  
  I는 Input디바이스(ex)키보드, 마우스)로 -> 컴퓨터 내부로 보내는 것을 의미,  
  O는 Output디바이스(ex)프린터, 컴퓨터모니터)로 <- 컴퓨터 내부에서 내보는 것을 의미,  
  디스크는 Input, output이 모두 가능

[그림에서 보이는, 메모리 안에 있는 운영체제는?]  
컴퓨터에 부팅이 일어난다는 것은 운영체제가 메모리에 올라간다는 것이다. => 운영체제라는 것은 컴퓨터가 꺼지기 전까지 항상 실행되는 것이다. => 그래서 운영체제의 핵심적인 것을 운영체제 커널이라고 부른다. 이 커널이 메모리에 상주해있다. => 그래서 이 운영체제 부분을 제외하고, 프로그램들이 나누어 메모리 공간을 차지한다.

[전체적인 과정]  
CPU는 메모리 어딘가에 있는 기계어를 하나씩 읽는다. => 프로세스A에 관해 읽다가, 디스크에 존재하는 파일의 내용이 필요하다. => 이는 **특권명령**이 필요하다. =>운영체제 커널 함수를 부른다.(시스템콜) => 시스템콜을 하면 프로세스A가 스스로 Interrupt를 건다. (프로세스A를 읽다가 운영체제의 메모리로 넘어가기 위한 방법은 Interrupt이니까, 그러나 좁은 의미로는 Interrupt보단 trap이라고 불림) => CPU는 Interrupt line을 체크를 통해, 메모리가 운영체제로 넘어간다. => 그래서 CPU가 device driver기계어로 디스크 Controller에게 요청한다 => 필요한 디스크 파일을 읽고, local buffer에 담는다.(이 동안에 CPU는 다른 프로그램의 일을 하고 있는다.) => 디스크 Controller가 인터럽트를 걸어서 CPU에 담았다고 알려준다 => 그러면 CPU는 인터럽트가 들어온게 확인되면 CPU의 제어권은 읽던 프로세스에서 운영체제로 넘어간다. => 운영체제는 인터럽트가 들어온 이유를 보고, 프로세스A가 필요한 파일이 온 것을 알고 프로세스A의 메모리 위치에 파일을 카피해준다. => 그리고 이제 프로세스A가 본인의 차례가 오면 CPU가 프로세스A 기계어를 읽을 수 있게 된다.

Q1. 그림의 a,b는 무엇인가?  
 I/O디바이스에 있는 a는 CPU Controller, b는 각 디바이스의 메모리이다.
CPU는 I/O디바이스에 직접 접근을 할 수는 없다. 각 I/O디바이스에 전담하는 CPU Controller가 있고, 또 각 I/O디바이스에 있는 메모리가 있다.  
Q2. CPU가 CPU Controller에게 요청하고 나서 무엇을 할까?  
 CPU는 다른 프로그램으로 넘어가서 작업을 한다. 이때, CPU가 기계어를 하나 읽을 후마다 매번 인터럽트된게 없는지를 체크한다.  
Q3. CPU는 그냥 메모리에 올라와있는 기계어를 읽을 뿐이다. 그렇다면 메모리에 있는 다른 프로그램으로 어떻게 넘겨서 다른 프로그램의 기계어를 읽는 것일까?  
 프로그램C를 읽다가 프로그램C의 기계어 중 프로그램A로 넘기라는 것을 읽고 CPU는 프로그램A로 넘어가라는 기계어를 읽을 뿐이다.  
Q4. Q3에서 그렇다면 어떤 프로그램에게 CPU권한을 줄 것인지를 어떻게 정하는 것일까?  
 CPU스케줄링  
Q5. cpu가 여러 프로그램을 돌다가, 각각의 프로그램에서 필요한 것들을 디스크에 요청을 하게 된다면 디스크도 무엇부터 처리할지?  
 디스크 스케줄링

[캐싱, 인터럽트]

- 느린I/O장치와 빠른CPU 장치간의 속도 차이의 극복은? => 인터럽트, 캐싱  
  *캐싱 : CPU와 메모리 사이에도 속도차이가 100배라서 그 사이에 캐싱을 두고, 메모리와 디스크 사이에도 속도차이가 나기 때문에 디스크에 필요한 데이터가 필요하면 디스크에 계속 들르지말고 메모리에 올려두고 그냥 바로 꺼내 쓸수 있게 하는 것이 캐싱 (재사용성)
  *인터럽트 : CPU가 CPU Controller에게 요청한 데이터를 다 처리되었을때, CPU에게 다 처리되었음을 알려주는 역할을 한다. CPU는 디스크보다 속도가 100만배가 빠르다. 그래서 느린 디스크를 기다리지않고 계속 일을 해야하니깐 그 전달(심부름) 역할을 해주는 인터럽트가 있는 것이다.

### 3.프로세스의 상태

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%9D%98%20%EC%83%81%ED%83%9C.png"
    width="400"
    height="400"
  />
</p>

- 실행중인 프로그램을 프로세스라고 부른다.(그림에서, 초록색 동그라미가 프로세스)
- cpu큐에 차곡차곡 실행될 프로세스가 순서대로 담긴다.
- 만약 CPU에 실행되던 프로세스가 디스크의 데이터가 필요하게 된다면 CPU큐에 담아도 어차피 기다려야하기때문에(disk Controller의 인터럽트가 올때까지), 거기에 넣지않고 디스크 입출력 큐(Device queues)에다가 담아둔다. 그러고 나서 나중에 인터럽트 작업이오고 메모리에 운영체제 작업을 거치면, 디스크 입출력 큐에 담아뒀던 프로세스가 다시 cpu큐(Ready queues)로 들어간다.
- 사람이 키보드를 두드리면 키보드 CPU Controller가 CPU에게 인터럽트를 걸어서 키보드에 입력이 들어옴을 알려줘서 CPU가 메모리에 있는 운영체제로 넘어가고 운영체제는 키보드입력으로 들어온데 이터를 메모리로 카피해서 그 프로그램이 사용할 수 있게 해준다.(2.운영체제의 기능/[전체적인 과정]을 대입해서 생각해보면 된다.)

### 4. 운영체제의 분류

- 동시 작업 가능 여부

1. 단일 작업(Single tasking) : 한 번에 하나의 작업만 처리
2. 다중 작업(Mutil tasking) : 동시에 두 개 이상의 작업 처리 => 현재 사용하는 방법

- 사용자의 수

1. 단일 사용자(Single user)
2. 다중 사용자(Mutil user), 단점은 물론 다양한 사람이 사용하므로, A사용자의 파일을 B가 보면 안되고 하는 등의 보안 문제를 해결해야한다. => 현재 사용하는 방법

- 처리 방식

1. 일괄 처리(batch processing) : 일정량을 한꺼번에 처리, 작업이 종료될때까지 기다려야 함.
2. 시분할(time sharing) : 여러 작업을 수행할 때 일정한 시간 단위로 분할하여 사용(마치 혼자 사용하는 것처럼 여러 사람에게 돌아가면서 결과를 준다), interactive한 방식(바로 결과가 나옴) => 현재 사용하는 방법
3. 실시간(Realtime OS) : 정해진 시간 안에 반드시!! 종료됨이 보장되어야하는 시스템 ex) 미사일제어, 원자로/공장 제어 등등  
   Hard realtime system(경성 실시간 시스템) : 1초도 잘못되면 정말 큰일 나는 것  
   Soft realtime system(경성 실시간 시스템) : 1초도 잘못되면 문제는 생기지만 엄청 큰일은 아닌 것

**용어**  
a. Mutiltasking : 동시에 2가지 이상의 작업 처리  
b. Mutilprogramming : 메모리에 여러 프로그램이 동시에 올라가 있는 것  
c. TimeSharing : CPU의 시간을 분할하여 나누어 쓴다.  
d. Multiprocessor : 하나의 컴퓨터에 CPU가 여러 개 붙어 있음을 의미. => 여러개의 CPU가 하나의 메모리를 공유해서 쓰면 문제가 복잡해짐.  
Mutiltasking, Mutilprogramming, TimeSharing은 비슷하다고 볼 수 있지만
Multiprocessor는 의미가 아예 다르다.

### 5. 운영체제의 예

1. 유닉스(UNIX)  
   코드의 대부분이 C언어로 작성 => 사람이 이해하기 쉽고, 그래서 복사해서 쓰기가 좋다, 기존의 운영체제는 어셈블리어였는데 이는 이해하기도 어렵고 기계가 바뀌면 새롭게 코딩해야했다.  
   높은 이식성(호환이 된다.)  
   최소한의 커널 구조  
   복잡한 시스템에 맞게 확장 용이  
   소스 코드 공개  
   프로그램 개발에 용이  
   다양한 버전 : Linux

2. DOS  
   MS사에서 개발
   단일 사용자, 단일 작업만이 가능함.

3. MS Windows  
   MS사에서 개발  
   DOS용과 호환 가능  
   초기에는 불안정함. => 다중 작업용 기반의 운영체제기 때문.

### 6.메모리관리

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC1.png"
    width="400"
    height="400"
  />
</p>

A. 실행파일이 실행되면, 바로 프로세스가 메모리에 올라가는게 아니라, 가상메모리에 형성이 된다.(각각 가상메모리의 주소0번지부터) => 그림에서 보면, 프로세스의 가상 메모리가 쪼개져있는데 저 단위를 페이지라고 부른다.  
B. 실제 물리적인 메모리에는 가상 메모리에서 당장 필요한 부분만 올라간다.  
C. 나머지 올라가지 못한 메모리는 스왑영역(디스크)으로 쫓겨나게 된다. 물리적인 메모리가 만약 꽉 차있는데, 또 다른 프로세스의 메모리가 물리적인 메모리에 올라가야한다면, 물리적인 메모리에 올라가 있던 프로세스의 메모리들이 스왑영역(디스크)으로 쫓겨나게 된다.

*파일시스템(디스크에 존재) : 텍스트 파일, 그림 파일, 프로그램 등 전원이 나가더라도 내용이 유지되어야하는 공간이다. => 비휘발성  
*스왑영역(디스크에 존재) : 물리적인 메모리의 연장공간으로써, 물리적인 메모리에 다 올라가지 못하기에 프로세스의 메모리를 담아두는 공간 => 비휘발성이지만, 전원이 꺼지면 살아는 있지만 휘발성인 메모리공간이 다 사라졌기 때문에, 프로세스가 돌아가지 않아서 그냥 쓸모없는 데이터일 뿐이다.

### 7.저장장치 계층구조

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0.png"
    width="400"
    height="400"
  />
</p>

- 계층구조를 하는 이유는?  
  속도 차이를 완충하기 위해서다. -> 어떻게 완충을 하는거지? "캐싱"  
  \*캐싱 : 어떤 데이터가 필요하다고하면 처음에는 갖다가 쓰겠지만, 재사용될 때는 중간 경로에 저장해두면(즉, 캐싱) 다시 요청이 됬을 때 아래부터 가져다 쓰지 않아도 된다. 그래서 시간을 SAVE시켜 속도 차이를 완충할 수 있다. -> 물론, 캐싱도 한정적인 용량이므로 누군가를 또 쫓아내고 저장하고 하긴 해야한다.

- 위쪽으로 갈수록 빠르고 비쌈 그래서 메모리 용량이 작음  
  메인메모리는 D램으로 휘발성(초록색), 디스크는 비휘발성(빨간색)  
  초록색은 CPU가 직접 실행할 수 있고, 빨간색은 CPU가 직접 접근을 못한다.

### 8. 플래시메모리

- 스마트폰, 테블릿, 카메라, 노트북컴퓨터(SSD가 플래시메모리가 들어가 있는 저장장치), USB 등에 들어가 있다.
- NAND형, NOR형 2가지가 있다. => 우리가 보통 사용하는 건 NAND형이다. 저장장치용
- 반도체장치이다.
- 특징 : 전원이 나가도 내용유지, 하드디스크에 비해(하드디스크는 원판을 돌려서 전력소모가 됨) 전력 소모가 적음, 물리적인 충격에 강하다(고장이 덜 난다), 크기가 작다, 가볍다 => 모바일 장치에 딱봐도 좋은게 느껴짐, 지금은 하드디스크의 대용으로 쓰는 SSD형태로도 사용이 된다.
- 하드디스크에 비해 단점  
  a. 쓰기 횟수 제약 => 썼다 지웠다하는 이 횟수 제약이 끝나면 더이상 사용을 하지 못한다.  
  b. 데이터가 시간이 흐르면서 변질 될 수 있다는 특징.(왜? 플래시메모리는 데이터의 1과 0을 구분하는 것이 셀 안에 들어있는 전하의 양으로 구분한다. 전하는 일정시간이 지나면 셀 안에서 조금씩 빠진다. 그래서 오랜시간이 흐르면, 전하의 양이 많이 빠져나가서 1로 읽혀야하는게 0으로 읽힐 수가 있다. 그러면서 데이터가 변질 됨.)  
  => 이러한 하드웨어의 약점을 소프트웨어를 하는 사람들이 이제 잘 만들어서 보완을 해야한다.  
  예를 들면, 일정시간이 흐르면 전하의 양이 빠져 나가므로 다른 셀에다가 다시 1을 써준다던지,  
  특정 셀만 너무 많이 써서 못 쓰는 걸 방지하기위해 골고루 플래시메모리가 사용되도록 한다던지,  
  등을 연구해야한다.

### 9. 운영체제의 종류

- 펭귄은 Linux를 뜻함. 모든 컴퓨터 운영체제에는 Linux가 거의 들어가 있다. Linux는 공개 소프트웨어이다(Open Source Software)
- 안드로이드 안에도 Linux커널이 들어가 있다.
- 서버용(Linux), PC용(windows, macOS, Linux), 스마트디바이스용(ios, android)
- 왜 Linux와 같이 Open Source Software가 있을까? 처음에는 시작에서 망했기때문에 나온것. 1등이 아예 장악이 되면서 안 팔리게 되니깐 그냥 무료로 공개. 이건 물건처럼 만드는 재료비가 따로 들지는 않으니까 딱히 비용이 필요가 없다.

---

출처: http://www.kocw.net/home/cview.do?lid=248a533dda95d005
출처: http://www.kocw.net/home/cview.do?lid=8a85bc6d5e6b1b83
