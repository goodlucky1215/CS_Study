### 1.CPU스케줄링

- CPU 스케줄링 종류  
  A. FCFS(First-Come First-Served) : 먼저온 프로세스를 먼저 처리한다.  
  B. SJF(Shortest-Job-First) : 가장 짧은 프로세스를 제일 먼저 처리한다. -> Starvation(기아 현상)발생(즉, CPU사용시간이 긴 프로세스는 계속 밀리는 현상)  
  C. RR(Round Robin) : 각 프로세스 동일 크기의 CPU할당시간을 가짐, 할당시간이 끝나면 인터럽트가 발생하여 프로세스는 CPU를 빼앗기고 CPU큐의 제일 뒤에 줄을 쓴다.

ex) 프로세스 p1, p2, p3의 순서로 들어왔고, 각각의 CPU사용시간 p1은 24, p2는 3, p3은 3  
Q1. FCFS(First-Come First-Served)의 기다리는 시간과 평균 기다리는 시간은?  
=> 기다린 시간 : p1은 0, p2는 24, p3은 27 이다.  
=> 평균 기다린 시간은 : (0+24+27)/3 = 17 이다.  
Q2. SJF(Shortest-Job-First)의 기다리는 시간과 평균 기다리는 시간은?  
=> 기다린 시간 : p1은 6, p2는 0, p3은 3 이다.  
=> 평균 기다린 시간은 : (6+0+3)/3 = 3 이다.  
Q3. RR(Round Robin)의 기다리는 시간과 평균 기다리는 시간은?  
(진입시간은 p1은 0, p2는 1, p3은 2, CPU할당 시간을 2이라고 가정)  
=> 기다린 시간 : p1은 2+2 = 4, p2는 (2-1)+4 = 5, p3은 (2-2)+3 = 3 이다. (기다린 시간에서 진입시간은 빼줘야한다.)  
=> 평균 기다린 시간은 : (4+5+3)/3 = 4 이다.

### 2.메모리관리

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC1.png"
    width="400"
    height="400"
  />
</p>

A. 실행파일이 실행되면, 바로 프로세스가 메모리에 올라가는게 아니라, 가상메모리에 형성이 된다.(각각 가상메모리의 주소0번지부터) => 그림에서 보면, 프로세스의 가상 메모리가 쪼개져있는데 저 단위를 페이지라고 부른다.  
B. 실제 물리적인 메모리에는 가상 메모리에서 당장 필요한 부분만 올라간다.  
C. 나머지 올라가지 못한 메모리는 스왑영역(디스크)으로 쫓겨나게 된다. 물리적인 메모리가 만약 꽉 차있는데, 또 다른 프로세스의 메모리가 물리적인 메모리에 올라가야한다면, 물리적인 메모리에 올라가 있던 프로세스의 메모리들이 스왑영역(디스크)으로 쫓겨나게 된다.

*파일시스템(디스크에 존재) : 텍스트 파일, 그림 파일, 프로그램 등 전원이 나가더라도 내용이 유지되어야하는 공간이다. => 비휘발성  
*스왑영역(디스크에 존재) : 물리적인 메모리의 연장공간으로써, 물리적인 메모리에 다 올라가지 못하기에 프로세스의 메모리를 담아두는 공간 => 비휘발성이지만, 전원이 꺼지면 살아는 있지만 휘발성인 메모리공간이 다 사라졌기 때문에, 프로세스가 돌아가지 않아서 그냥 쓸모없는 데이터일 뿐이다.

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B4%80%EB%A6%AC2.png"
    width="400"
    height="400"
  />
</p>

A. cpu가 요청한 메모리를 디스크에 있는 메모리의 페이지를 물리적인 메모리에 올린다.  
B. 처음에는 물리적인 메모리에 순서대로 들어보낸다.  
C. 페이지5번을 사용해야하는데, 메모리가 꽉 찬다면?  
 LRU(가장 오래 전에 참조 페이지를 삭제) => 페이지1번을 삭제  
 LFU(참조횟수가 가장 적은 페이지를 삭제) => 페이지4번을 삭제

### 3.디스크 스케줄링

- 디스크 접근 시간(Access time)의 3가지 구성

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%94%94%EC%8A%A4%ED%81%AC%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%811.png"
    width="400"
    height="400"
  />
</p>

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%94%94%EC%8A%A4%ED%81%AC%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%812.png"
    width="400"
    height="400"
  />
</p>

A. 탐색시간(Seek time) : 헤드를 해당 트랙(실린더)으로 움직이는데 걸리는 시간 => 헤드의 이동시간이 디스크 접근 시간 중에 가장 많은 시간을 뺏는다. 그래서 헤드의 이동 시간을 줄이는게 제일 중요하다.  
ex) 트랙의 몇 번으로 이동하는 지에 대한 시간  
B. 회전지연(Rotational latency) : 헤드가 원하는 섹터에 도달하기까지 걸리는 시간  
ex) 맞는 트랙에 도착 후에, 내가 찾으려는 섹터(그 원 안에 조각 1개를 섹터라고 부름)까지 또 찾아야하는데, 그 시간을 의미 => 2번째로 시간을 많이 뺏는다.  
C. 전송시간(Transfer time) : 실제 데이터의 전송 시간  
ex) 맞는 섹터에 도착해서 저 막대기(마그네틱)에 읽거나 쓰는 그 시간. => 제일 시간을 적게 뺏는다.

- 디스크 스케줄링 종류  
  => 디스크 스케줄링의 목표는 Seek time을 줄이는 것이다.

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%94%94%EC%8A%A4%ED%81%AC%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%813.PNG"
    width="400"
    height="400"
  />
</p>

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EB%94%94%EC%8A%A4%ED%81%AC%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%814.png"
    width="400"
    height="400"
  />
</p>

A. FCFS(First-Come First-Served) : 들어온 순서대로 처리  
B. SSTF(Shortest Seek Time First) : 큐에서 가까운에부터 먼저 처리하는 방법 => Starvation(기아 현상)발생  
C. SCAN : 헤드가 디스크의 한쪽 끝에서 다른쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리하는 것. 큐에 들어온 것을 고려하지않고, 그냥 자기 갈 길만을 가면서 처리하는 것임.

### 4.저장장치 계층구조

<p align="center">
  <img
    src="https://github.com/goodlucky1215/CS_Study/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/1.%20%EA%B0%9C%EC%9A%94/%EC%82%AC%EC%A7%84/%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0.png"
    width="400"
    height="400"
  />
</p>

- 계층구조를 하는 이유는?  
  속도 차이를 완충하기 위해서다. -> 어떻게 완충을 하는거지? "캐싱"  
  \*캐싱 : 어떤 데이터가 필요하다고하면 처음에는 갖다가 쓰겠지만, 재사용될 때는 중간 경로에 저장해두면(즉, 캐싱) 다시 요청이 됬을 때 아래부터 가져다 쓰지 않아도 된다. 그래서 시간을 SAVE시켜 속도 차이를 완충할 수 있다. -> 물론, 캐싱도 한정적인 용량이므로 누군가를 또 쫓아내고 저장하고 하긴 해야한다.

- 위쪽으로 갈수록 빠르고 비쌈 그래서 메모리 용량이 작음  
  메인메모리는 D램으로 휘발성(초록색), 디스크는 비휘발성(빨간색)  
  초록색은 CPU가 직접 실행할 수 있고, 빨간색은 CPU가 직접 접근을 못한다.

### 5. 플래시메모리

- 스마트폰, 테블릿, 카메라, 노트북컴퓨터(SSD가 플래시메모리가 들어가 있는 저장장치), USB 등에 들어가 있다.
- NAND형, NOR형 2가지가 있다. => 우리가 보통 사용하는 건 NAND형이다. 저장장치용
- 반도체장치이다.
- 특징 : 전원이 나가도 내용유지, 하드디스크에 비해(하드디스크는 원판을 돌려서 전력소모가 됨) 전력 소모가 적음, 물리적인 충격에 강하다(고장이 덜 난다), 크기가 작다, 가볍다 => 모바일 장치에 딱봐도 좋은게 느껴짐, 지금은 하드디스크의 대용으로 쓰는 SSD형태로도 사용이 된다.
- 하드디스크에 비해 단점  
  a. 쓰기 횟수 제약 => 썼다 지웠다하는 이 횟수 제약이 끝나면 더이상 사용을 하지 못한다.  
  b. 데이터가 시간이 흐르면서 변질 될 수 있다는 특징.(왜? 플래시메모리는 데이터의 1과 0을 구분하는 것이 셀 안에 들어있는 전하의 양으로 구분한다. 전하는 일정시간이 지나면 셀 안에서 조금씩 빠진다. 그래서 오랜시간이 흐르면, 전하의 양이 많이 빠져나가서 1로 읽혀야하는게 0으로 읽힐 수가 있다. 그러면서 데이터가 변질 됨.)  
  => 이러한 하드웨어의 약점을 소프트웨어를 하는 사람들이 이제 잘 만들어서 보완을 해야한다.  
  예를 들면, 일정시간이 흐르면 전하의 양이 빠져 나가므로 다른 셀에다가 다시 1을 써준다던지,  
  특정 셀만 너무 많이 써서 못 쓰는 걸 방지하기위해 골고루 플래시메모리가 사용되도록 한다던지,  
  등을 연구해야한다.

### 6. 운영체제의 종류

- 펭귄은 Linux를 뜻함. 모든 컴퓨터 운영체제에는 Linux가 거의 들어가 있다. Linux는 공개 소프트웨어이다(Open Source Software)
- 안드로이드 안에도 Linux커널이 들어가 있다.
- 서버용(Linux), PC용(windows, macOS, Linux), 스마트디바이스용(ios, android)
- 왜 Linux와 같이 Open Source Software가 있을까? 처음에는 시작에서 망했기때문에 나온것. 1등이 아예 장악이 되면서 안 팔리게 되니깐 그냥 무료로 공개. 이건 물건처럼 만드는 재료비가 따로 들지는 않으니까 딱히 비용이 필요가 없다.

---

출처: http://www.kocw.net/home/cview.do?lid=8a85bc6d5e6b1b83
